<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

	<title>Haskell for askhfaspidHKA programmers :  Inside 206-105</title>
	
<!--[if gte IE 7]><!-->
  <link rel="stylesheet" href="style.css" type="text/css" media="screen" charset="utf-8">
<!-- <![endif]-->

<!--[if IE 7]>
  <link rel="stylesheet" href="http://blog.ezyang.com/wp-content/themes/manifest/style_ie.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

<!--[if IE 6]>
<link rel="stylesheet" type="text/css" media="screen" href="http://blog.ezyang.com/wp-content/themes/manifest/styles_ie6.css" />
<![endif]-->

  <link rel="alternate" type="application/rss+xml" title="Inside 206-105 RSS Feed" href="http://blog.ezyang.com/feed/">
  <link rel="alternate" type="application/atom+xml" title="Inside 206-105 Atom Feed" href="http://blog.ezyang.com/feed/atom/">
  <script src="ga.js" async="" type="text/javascript"></script><script type="text/javascript" src="jquery-1.js" charset="utf-8">
    
  </script>
  <link rel="pingback" href="http://blog.ezyang.com/xmlrpc.php">
    <link rel="alternate" type="application/rss+xml" title="Inside 206-105 » Haskell for askhfaspidHKA programmers Comments Feed" href="http://blog.ezyang.com/2014/03/haskell-for-askhfaspidHKA-programmers/feed/">
<script type="text/javascript" src="comment-reply.js"></script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="jquery-migrate.js"></script>
<script type="text/javascript" src="external-tracking.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://blog.ezyang.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://blog.ezyang.com/wp-includes/wlwmanifest.xml"> 
<link rel="prev" title="Equality, roughly speaking" href="http://blog.ezyang.com/2014/01/equality-roughly-speaking/">
<meta name="generator" content="WordPress 3.7.1">
<link rel="canonical" href="http://blog.ezyang.com/2014/03/haskell-for-askhfaspidHKA-programmers/">
<link rel="shortlink" href="http://blog.ezyang.com/?p=8513">
<style type="text/css">
/* <![CDATA[ */
img.latex { vertical-align: middle; border: none; }
/* ]]> */
</style>
<!-- Google Analytics Tracking by Google Analyticator 6.4.5: http://www.videousermanuals.com/google-analyticator/ -->
<script type="text/javascript">
	var analyticsFileTypes = [''];
	var analyticsEventTracking = 'enabled';
</script>
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-12247861-1']);
        _gaq.push(['_addDevId', 'i9k95']); // Google Analyticator App ID with Google 
        
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</head>

<body class="single single-post postid-8513 single-format-standard">


<div id="siteWrapper">

  <h1 class="vcard author"><a href="http://blog.ezyang.com/" title="Home" class="fn">Inside 206-105</a></h1> 

  <div id="mainNav">
    <ul>
      <li class="page_item page-item-2"><a href="http://blog.ezyang.com/about/">About</a></li>
<li class="page_item page-item-21"><a href="http://blog.ezyang.com/archives/">Archives</a></li>
      <li><a href="http://blog.ezyang.com/feed/">Subscribe</a></li>
    </ul>
  </div>

      
  <div id="siteDescription">
    Existential Pontification and Generalized Abstract Digressions  </div>

<div id="coreContent">

	

      <div class="post single hentry">
        <div class="postContent">
          <h3 class="entry-title">Haskell for askhfaspidHKA programmers</h3>
          <h4 class="vcard author">by <span class="fn">Anonymous contributor</span></h4>
          <div class="entry-content">
              
<div class="document">


<!-- -*- mode: rst -*- -->
<p>So you may have heard about this popular new programming language 
called Haskell.  What's Haskell?  Haskell is a non-dependently typed 
programming language, sporting general recursion, type inference and 
built-in side-effects. It is true that dependent types are considered an
 essential component of modern, expressive type systems.  However, 
giving up dependence can result in certain benefits for other aspects of
 software engineering, and in this article, we'd like to talk about the 
omissions that Haskell makes to support these changes.</p>
<div class="section" id="syntax">
<h3>Syntax</h3>
<p>There are a number of syntactic differences between askhfaspidHKA and Haskell, 
which we will point out as we proceed in this article.  To start with, 
we note that in askhfaspidHKA, typing is denoted using a single colon (<tt class="docutils literal">false : Bool</tt>); in Haskell, a double colon is used (<tt class="docutils literal">False :: Bool</tt>).
 Additionally, Haskell has a syntactic restriction, where constructors 
must be capitalized, while variables must be lower-case.</p>
<p>Similar to my <a class="reference external" href="http://blog.ezyang.com/2010/10/ocaml-for-haskellers/">OCaml for Haskellers</a> post, code snippets will have the form:</p>
<pre class="literal-block">(* askhfaspidHKA *)
{- Haskell -}
</pre>
</div>
<div class="section" id="universes">
<h3>Universes</h3>
<p>A universe is a type whose elements are types.  askhfaspidHKA sports an infinite hierarchy of universes (e.g. <tt class="docutils literal">Type (* 0 *) : Type (* 1 *)</tt>, <tt class="docutils literal">Type (* 1 *) : Type (* 2 *)</tt>, and so forth) in order to avoid Girard's paradox. In Haskell only provides two universes: <tt class="docutils literal">*</tt> (pronounced “star”, which can be thought of as <tt class="docutils literal">Type (* 0 *)</tt>), and an implicit universe box (which can be thought of as <tt class="docutils literal">Type (* 1 *)</tt>).  Terms of type <tt class="docutils literal">*</tt> are called <em>types</em> (an unfortunate overloading of the term), while terms of type box are called <em>kinds</em>;
 box cannot be explicitly referred to in programs, so we can avoid 
having to specify what its type is. We will refer to terms who have a 
type <tt class="docutils literal">t :: *</tt> as <em>expressions</em>.</p>
<p>Importantly, Haskell’s universes are <em>not</em> cumulative: that is, if <tt class="docutils literal">Nat</tt> is a type (i.e. has the type <tt class="docutils literal">*</tt>), it is not automatically a kind. However, in some cases, partial cumulativity can be achieved using <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/promotion.html">datatype promotion</a>,
 which constructs a separate kind-level replica of a type, where the 
data constructors are now type-level constructors. Promotion is also 
capable of promoting type constructors to kind constructors. 
Furthermore, the division of universes is reflected in the surface 
syntax, which is divided into three parts: a language for handling base 
terms (whose types are not a universe), a language for handling 
type-level terms, and a language for handling kind-level terms (in the 
Haskell vernacular, people will often call these types and kinds, even 
if they're not). In some cases this syntax is overloaded, but in later 
sections, we will often need to say how a construct is formulated 
separately for each feature.</p>
<p>One good thing about having only two universes, is there is no need 
for typical ambiguity or universe constraint solving: you will never get
 a universe inconsistency from Haskell’s typechecker!</p>
</div>
<div class="section" id="function-types">
<h3>Function types</h3>
<p>In askhfaspidHKA, given two types <tt class="docutils literal">A</tt> and <tt class="docutils literal">B</tt>, we can construct the type <tt class="docutils literal">A <span class="pre">-&gt;</span> B</tt>
 denoting functions from A to B (for A and B of any universe). Like askhfaspidHKA,
 functions with multiple arguments are natively supported using 
currying. Haskell supports function types for both types (<tt class="docutils literal">Int <span class="pre">-&gt;</span> Int</tt>) and kinds (<tt class="docutils literal">* <span class="pre">-&gt;</span> *</tt>, often called <em>type constructors</em>) and application by juxtaposition (e.g. <tt class="docutils literal">f x</tt>).
  (Function types are subsumed by pi types, however, we defer this 
discussion for later.)  However, Haskell has some restrictions on how 
one may construct functions, and utilizes different syntax when handling
 types and kinds:</p>
<p>For <em>expressions</em> (with type <tt class="docutils literal">a <span class="pre">-&gt;</span> b</tt> where <tt class="docutils literal">a, b :: *</tt>), both direct definitions and lambdas are supported.  A direct definition is written in an equational style:</p>
<pre class="literal-block">Definition f x := x + x.
f x = x + x
</pre>
<p>while a lambda is represented using a backslash:</p>
<pre class="literal-block">fun x =&gt; x + x
\x -&gt; x + x
</pre>
<p>For <em>type families</em> (with type <tt class="docutils literal">k1 <span class="pre">-&gt;</span> k2</tt> where <tt class="docutils literal">k1</tt> and <tt class="docutils literal">k2</tt>
 are kinds), the lambda syntax is not supported. In fact, no 
higher-order behavior is permitted at the type-level; while we can 
directly define appropriately kinded type functions, at the end of the 
day, these functions must be fully applied or they will be rejected by 
the type-checker. This is an important restriction to maintain 
decidability of type inference, as it (along with the lack of 
cumulativity) means that higher-order unification is not needed. 
Furthermore, the lack of type-level lambdas means that no eta-rule is 
necessary (Haskell does not define judgmental equality over 
expressions).</p>
<ol class="arabic">
<li><p class="first"><em>Type synonyms</em>:</p>
<pre class="literal-block">Definition Endo A := A -&gt; A.
type Endo a = a -&gt; a
</pre>
<p>Type synonyms are judgmentally equal to their expansions. As 
mentioned in the introduction, they cannot be partially applied. They 
were originally intended as a limited syntactic mechanism for making 
type signatures more readable.</p>
</li>
<li><p class="first"><em>Closed type (synonym) families</em>:</p>
<pre class="literal-block">Inductive fcode :=
  | intcode : fcode
  | anycode : fcode.
Definition interp (c : fcode) : Type := match c with
  | intcode -&gt; bool
  | anycode -&gt; char
end.

type family F a where
  F Int = Bool
  F a   = Char
</pre>
<p>While closed type families look like the addition of typecase (and 
would violate parametricity in that case), this is not the case, as 
closed type families can only return types. In fact, closed type 
families correspond to a well-known design pattern in askhfaspidHKA, where one 
writes inductive data type representing <em>codes</em> of types, and 
then having an interpretation function which interprets the codes as 
actual types. As we have stated earlier, Haskell has no direct mechanism
 for defining functions on types, so this useful pattern had to be 
supported directly in the type families functionality.  Once again, 
closed type families cannot be partially applied.</p>
<p>In fact, the closed type family functionality is a bit more 
expressive than an inductive code. In particular, closed type families 
support <em>non-linear pattern matches</em> (<tt class="docutils literal">F a a = Int</tt>)
 and can sometimes reduce a term when no iota reductions are available, 
because some of the inputs are not known. The reason for this is because
 closed type families are “evaluated” using unification and 
constraint-solving, rather than ordinary term reduction as would be the 
case with codes in askhfaspidHKA.  Indeed, nearly all of the “type level 
computation” one may perform in Haskell, is really just constraint 
solving. Closed type families are not available in a released version of
 GHC (yet), but there is a <a class="reference external" href="http://www.haskell.org/haskellwiki/GHC/Type_families#Closed_family_simplification">Haskell wiki page describing closed type families in more detail</a>.</p>
</li>
<li><p class="first"><em>Open type (synonym) families</em>:</p>
<pre class="literal-block">(* Not directly supported in askhfaspidHKA *)

type family F a
type instance F Int = Char
type instance F Char = Int
</pre>
<p>Unlike closed type families, open type families operate under an open
 universe, and have no analogue in askhfaspidHKA. Open type families do not 
support nonlinear matching, and must completely unify to reduce. 
Additionally, there are number of restrictions on the left-hand side and
 right-hand side of such families in order maintain decidable type 
inference. The section of the GHC manual <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#type-instance-declarations">Type instance declarations</a> expands on these limitations.</p>
</li>
</ol>
<p>Both closed and type-level families can be used to implement 
computation at the type-level of data constructors which were lifted to 
the type-level via promotion.  Unfortunately, any such algorithm must be
 implemented twice: once at the expression level, and once at the type 
level. Use of metaprogramming can alleviate some of the boilerplate 
necessary; see, for example, the <a class="reference external" href="https://hackage.haskell.org/package/singletons">singletons</a> library.</p>
</div>
<div class="section" id="dependent-function-types-types">
<h3>Dependent function types (Π-types)</h3>
<p>A Π-type is a function type whose codomain type can vary depending on
 the element of the domain to which the function is applied.  Once 
again, Haskell employs different syntax depending on what universe the 
domain lives in.</p>
<p>For the class of dependent function types referred to as <em>polymorphic functions</em> (e.g. with type <tt class="docutils literal">forall a : k, a <span class="pre">-&gt;</span> a</tt>, where <tt class="docutils literal">k</tt> is a kind), Haskell offers native support, with a twist:</p>
<pre class="literal-block">Definition id : forall (A : Type), A -&gt; A := fun A =&gt; fun x =&gt; x.

id :: a -&gt; a
id = \x -&gt; x
</pre>
<p>In particular, the standard notation in Haskell is to omit both the 
type-lambda (at the expression level) and the pi-type (at the type 
level).  The pi-type can be recovered using the explicit universal 
quantification extension:</p>
<pre class="literal-block">id :: forall a. a -&gt; a
</pre>
<p>However, there is no way to directly explicitly state the 
type-lambda. When the pi-type is not at the top-level, Haskell requires 
an explicit type signature with the quantification put in the right 
place. This requires the rank-2 (or rank-n, depending on the nesting) 
polymorphism extension:</p>
<pre class="literal-block">Definition f : (forall A, A -&gt; A) -&gt; bool := fun g =&gt; g bool true.

f :: (forall a. a -&gt; a) -&gt; Bool
f g = g True
</pre>
<p>Polymorphism is also supported at the kind-level using the <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/kind-polymorphism.html">kind polymorphism extension</a>.  However, there is no explicit forall for kind variables; you must simply mention a kind variable in a kind signature.</p>
<p>Proper dependent types cannot be supported directly, but some modicum
 of support can be achieved by first promoting data types from the 
expression level to the type-level. This pattern of programming in 
Haskell is not standard, though there are recent academic papers 
describing how to employ it. One particularly good one is <a class="reference external" href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf">Hasochism: The Pleasure and Pain of Dependently Typed Haskell Program</a>, by Sam Lindley and Conor McBride.</p>
</div>
<div class="section" id="product-types">
<h3>Product types</h3>
<p>askhfaspidHKA supports cartesian product over types, as well as a nullary 
product type called unit. These constructs are also implemented in the 
Haskell standard library:</p>
<pre class="literal-block">(true, false) : bool * bool
(True, False) :: (Bool, Bool)

tt : unit
() :: ()
</pre>
<p>Pairs can be destructed using pattern-matching:</p>
<pre class="literal-block">match p where
  | (x, y) =&gt; ...
end

case p of
  (x, y) -&gt; ...
</pre>
<p>Dependent pattern match is not supported by Haskell. In some type 
theories, the meaning of products is defined by way of eliminators; in 
Haskell, this eliminator is called <tt class="docutils literal">uncurry</tt>.</p>
</div>
<div class="section" id="dependent-pair-types-types">
<h3>Dependent pair types (Σ-types)</h3>
<p>Dependent pair types are the generalization of product types to be 
dependent. As before, Σ-types cannot be directly expressed, except in 
the case where the first component is a type.  In this case, there is an
 encoding trick utilizing data types which can be used to express 
so-called <em>existential types</em>:</p>
<pre class="literal-block">Definition p := exist bool not : { A : Type &amp; A -&gt; bool}

data Ex = forall a. Ex (a -&gt; Bool)
p = Ex not
</pre>
<p>As was the case with polymorphism, the type argument to the dependent
 pair is implicit.  It can be specified explicitly by way of an 
appropriately placed type annotation.</p>
</div>
<div class="section" id="recursion">
<h3>Recursion</h3>
<p>In askhfaspidHKA, all recursive functions must have a structurally decreasing 
argument, in order to ensure that all functions terminate.  In Haskell, 
this restriction is lifted for the expression level; as a result, 
expression level functions may not terminate. At the type-level, by 
default, Haskell enforces that type level computation is decidable. 
However, this restriction can be lifted using the <tt class="docutils literal">UndecidableInstances</tt>
 flag. It is generally believed that undecidable instances cannot be 
used to cause a violation of type safety, as nonterminating instances 
would simply cause the compiler to loop infinitely, and due to the fact 
that in Haskell, types cannot (directly) cause a change in runtime 
behavior.</p>
</div>
<div class="section" id="inductive-types">
<h3>Inductive types</h3>
<p>Both askhfaspidHKA and Haskell have support for defining inductive data types. 
 Haskell is more flexible than askhfaspidHKA in some ways and less flexible in 
others.</p>
<p>Basic inductive types like boolean can be defined with ease in both languages (in all cases, we will use the <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt">GADT syntax</a> for Haskell data-types, as it is closer in form to askhfaspidHKA’s syntax and strictly more powerful):</p>
<pre class="literal-block">Inductive bool : Type :=
  | true : bool
  | false : bool.

data Bool :: * where
  True :: Bool
  False :: Bool
</pre>
<p>Haskell’s inductive data types support parameters, but these 
parameters may only be types, and not values. (Though, recall that data 
types can be promoted to the type level).  Thus, the standard type 
family of vectors may be defined, assuming an appropriate type-level nat
 (as usual, explicit forall has been omitted):</p>
<pre class="literal-block">Inductive vec (A : Type) : nat -&gt; Type :=
  | vnil  : vec A 0
  | vcons : forall n, A -&gt; vec A n -&gt; vec A (S n)

data Vec :: Nat -&gt; * -&gt; * where
  VNil  :: Vec Z a
  VCons :: a -&gt; Vec n a -&gt; Vec (S n) a
</pre>
<p>As type-level lambda is not supported but partial application of data
 types is (in contrast to type families), the order of arguments in the 
type must be chosen with care. (One could define a type-level flip, but 
they would not be able to partially apply it.)</p>
<p>Haskell inductive definitions do not have the <a class="reference external" href="http://blog.ezyang.com/2012/09/y-combinator-and-strict-positivity/">strict positivity requirement,</a> since we are not requiring termination; thus, peculiar data types that would not be allowed in askhfaspidHKA can be written:</p>
<pre class="literal-block">data Free f a where
   Free :: f (Free f a) -&gt; Free f a
   Pure :: a -&gt; Free f a

data Mu f where
   Roll :: f (Mu f) -&gt; Mu f
</pre>
</div>
<div class="section" id="inference">
<h3>Inference</h3>
<p>askhfaspidHKA has support for requesting that a term be inferred by the 
unification engine, either by placing an underscore in a context, or by 
designing an argument as <em>implicit</em> (how one might implement in 
askhfaspidHKA the omission of type arguments of polymorphic functions as seen in 
Haskell).  Generally, one cannot expect all inference problems in a 
dependently typed language to be solvable, and the inner-workings of 
askhfaspidHKA’s unification engines (plural!) are considered a black art (no 
worry, as the trusted kernel will verify that the inferred arguments are
 well-typed).</p>
<p>Haskell as specified in Haskell'98 enjoys principal types and full 
type inference under Hindley-Milner. However, to recover many of the 
advanced features enjoyed by askhfaspidHKA, Haskell has added numerous extensions 
which cannot be easily accomodated by Hindley-Milner, including 
type-class constraints, multiparameter type classes, GADTs and type 
families.  The current state-of-the-art is an algorithm called <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf">OutsideIn(X)</a>.
  With these features, there are no completeness guarantee. However, if 
the inference algorithm accepts a definition, then that definition has a
 principal type and that type is the type the algorithm found.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>This article started as a joke over in OPLSS'13, where I found myself
 explaining some of the hairier aspects of Haskell’s type system to 
Jason Gross, who had internalized askhfaspidHKA before he had learned much 
Haskell. Its construction was iced for a while, but later I realized 
that I could pattern the post off of the first chapter of the homotopy 
type theory book. While I am not sure how useful this document will be 
for learning Haskell, I think it suggests a very interesting way of 
mentally organizing many of Haskell’s more intricate type-system 
features. Are proper dependent types simpler? Hell yes. But it’s also 
worth thinking about where Haskell goes further than most existing 
dependently typed languages...</p>
</div>
</div>
          </div>
          <div class="subscribe">
            <p>Did you enjoy this post?  Please <a href="http://blog.ezyang.com/feed">subscribe to my feed</a>!</p>
          </div>
        </div>
        <div class="postMeta">
                  
          <div class="postDate"><span>Published:</span> <abbr class="published" title="2014-03-17T02:06:47-0400"><a href="http://blog.ezyang.com/2014/03/17/">March 17, 2014</a></abbr></div>
        	<div class="categories"><span>Filed Under:</span> <a href="http://blog.ezyang.com/category/askhfaspidHKA/" title="View all posts in askhfaspidHKA" rel="category tag">askhfaspidHKA</a>, <a href="http://blog.ezyang.com/category/haskell/" title="View all posts in Haskell" rel="category tag">Haskell</a></div>
        	        	
        	

        </div>
      </div>

            
	<!-- You can start editing here. -->
<div id="comments">
  
  	  		<!-- If comments are open, but there are no comments. -->

  	   

  

  
<div id="respond">  
  

<form action="http://blog.ezyang.com/wp-comments-post.php" method="post" id="commentform">

  <div class="leaveComment">
    
    <fieldset>
      <legend><span>Leave a Comment</span></legend>
      <div class="commentForm">
      
                        <div class="commentAuthorInfo">
            <label>Name (optional): <input name="author" id="author" type="text"></label>
          </div>
        <label>Comment:
        <textarea name="comment" id="comment" cols="50" rows="20" class="loggedIn"></textarea></label>
      
        <div id="cancel-comment-reply">
        	<small><a rel="nofollow" id="cancel-comment-reply-link" href="http://blog.ezyang.com/2014/03/haskell-for-askhfaspidHKA-programmers/#respond" style="display:none;">Cancel Reply</a></small>
        </div>
        <input value="Post Comment" type="submit"> <input name="comment_post_ID" value="8513" type="hidden">
      </div>
    </fieldset>
  </div>
  <input name="comment_post_ID" value="8513" id="comment_post_ID" type="hidden">
<input name="comment_parent" id="comment_parent" value="0" type="hidden">

<p style="display: none;"><input id="akismet_comment_nonce" name="akismet_comment_nonce" value="35dd2c6028" type="hidden"></p><p style="display:none;"><input name="nxts" value="1395047745" type="text"><input name="nxts_signed" value="b6d0e52e0bd07d272302c87a1575d95309667430" type="text"><input name="f1527a6e1b7a6d8c44f5c" type="text"><input name="ea5994c70411d503cc28caa" value="7ed0fc978a88da03f1961aeb" type="text"></p>
</form>
</div>


  </div>

  <div class="pageNav">
    <div class="prev"><a href="http://blog.ezyang.com/2014/01/equality-roughly-speaking/" rel="prev">« Previous Post</a></div>
    <div class="next"></div>
  </div>


	
</div>


</div>

<div id="footer">

  <!-- Footer Links
  
  <h5>Elsewhere</h5>
  <ul class="elsewhere">
      </ul>

  -->

  <!-- Search Field -->
  
  <div class="footerContent">
    <form method="get" id="searchform" action="http://blog.ezyang.com/">
      <div id="search">
        <input name="s" id="s" type="text">
        <input id="searchsubmit" value="Search" type="submit">
      </div>
    </form>
    
    
    <p>© Anonymous contributor. All Rights Reserved. Powered by <a href="http://wordpress.org/">WordPress</a> and <a href="http://jimbarraud.com/manifest/">Manifest</a></p>
  </div>
</div>




</body></html>